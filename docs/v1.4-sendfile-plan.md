# v1.4 Performance Upgrade: sendfile Implementation Plan

## Overview

Implement Linux `sendfile()` syscall for serving cached files directly from disk to client socket, achieving **2.6x throughput improvement** for files ≥1MB.

### Benchmark Results (from research)

| File Size | read+write | sendfile | Improvement |
|-----------|------------|----------|-------------|
| 4KB | 4.19µs | 3.59µs | 14% faster |
| 64KB | 7.83µs | 6.11µs | 22% faster |
| 1MB | 126µs | 49µs | **2.6x faster** |
| 10MB | 1.29ms | 467µs | **2.76x faster** |

### Architecture

```
Current flow (all files):
  DiskCache.get() → Bytes → Pingora → write() → Client

New flow (Linux, large cached files):
  DiskCache.get_sendfile_path() → fd → sendfile() → Client

Fallback (non-Linux, small files, non-cacheable):
  DiskCache.get() → Bytes → Pingora → write() → Client
```

---

## Phase 1: sendfile Abstraction Layer

**PR Title:** `feat(cache): add sendfile abstraction for zero-copy file serving`

### Tasks

- [ ] Create `src/cache/sendfile.rs` module with:
  - [ ] `SendfileCapable` trait for backends that support sendfile
  - [ ] `SendfileResponse` struct containing file path, offset, length
  - [ ] Linux `sendfile()` wrapper function with proper error handling
  - [ ] Feature detection for sendfile support

- [ ] Add configuration option:
  - [ ] `sendfile_enabled: bool` (default: true on Linux)
  - [ ] `sendfile_threshold_bytes: u64` (default: 64KB - files larger than this use sendfile)

- [ ] Unit tests:
  - [ ] Test sendfile wrapper with temp files
  - [ ] Test fallback behavior on non-Linux
  - [ ] Test threshold logic

### Files to Create/Modify
- `src/cache/sendfile.rs` (new)
- `src/cache/mod.rs` (export sendfile module)
- `src/cache/config.rs` (add sendfile config)

---

## Phase 2: DiskCache sendfile Integration

**PR Title:** `feat(disk_cache): implement sendfile path for cached file serving`

### Tasks

- [ ] Extend `DiskBackend` trait:
  - [ ] Add `fn supports_sendfile(&self) -> bool`
  - [ ] Add `fn get_file_path(&self, key: &CacheKey) -> Option<PathBuf>`

- [ ] Implement in `TokioFsBackend`:
  - [ ] Return file path for sendfile-capable responses

- [ ] Implement in `UringBackend` (Linux):
  - [ ] Return file path for sendfile-capable responses

- [ ] Extend `DiskCache`:
  - [ ] Add `get_sendfile(&self, key: &CacheKey) -> Result<Option<SendfileResponse>>`
  - [ ] Returns `SendfileResponse` with path, size, content-type, etag
  - [ ] Only returns sendfile response if file size > threshold

- [ ] Update `Cache` trait:
  - [ ] Add `get_sendfile()` method with default implementation returning `None`

- [ ] Unit tests:
  - [ ] Test `get_sendfile()` returns path for large files
  - [ ] Test `get_sendfile()` returns None for small files
  - [ ] Test metadata (content-type, etag) preserved

### Files to Modify
- `src/cache/traits.rs`
- `src/cache/disk/backend.rs`
- `src/cache/disk/tokio_backend.rs`
- `src/cache/disk/uring_backend.rs`
- `src/cache/disk/disk_cache.rs`

---

## Phase 3: Proxy sendfile Integration

**PR Title:** `feat(proxy): use sendfile for serving large cached files`

### Tasks

- [ ] Create sendfile response helper in proxy:
  - [ ] `fn serve_with_sendfile(session: &Session, response: SendfileResponse) -> Result<()>`
  - [ ] Opens file, gets raw fd
  - [ ] Calls sendfile() in a loop until complete
  - [ ] Handles partial writes and errors

- [ ] Modify cache hit path in `S3ProxyHttp::request_filter()`:
  - [ ] Check if sendfile is available for cache hit
  - [ ] If yes, use sendfile path instead of returning Bytes
  - [ ] Set appropriate response headers (Content-Type, ETag, Content-Length)

- [ ] Handle edge cases:
  - [ ] Range requests: skip sendfile (already bypass cache)
  - [ ] HEAD requests: skip sendfile (no body)
  - [ ] Non-Linux: fallback to normal path

- [ ] Add metrics:
  - [ ] `cache_sendfile_total` - count of sendfile responses
  - [ ] `cache_sendfile_bytes_total` - bytes served via sendfile

- [ ] Integration tests:
  - [ ] Test large file served via sendfile
  - [ ] Test small file served via normal path
  - [ ] Test fallback on error

### Files to Modify
- `src/proxy/mod.rs`
- `src/proxy/helpers.rs` (new helper functions)
- `src/metrics/mod.rs`

---

## Phase 4: Testing, Benchmarks & Documentation

**PR Title:** `test(sendfile): add comprehensive tests and benchmarks`

### Tasks

- [ ] Add integration tests:
  - [ ] `tests/sendfile_integration.rs`
  - [ ] Test with MinIO + large files
  - [ ] Verify file integrity after sendfile transfer
  - [ ] Test concurrent sendfile requests

- [ ] Add/update benchmarks:
  - [ ] Update `benches/disk_cache.rs` with sendfile comparison
  - [ ] Add `benches/sendfile_proxy.rs` for end-to-end measurement

- [ ] Update documentation:
  - [ ] Update README.md with sendfile feature
  - [ ] Update CLAUDE.md with sendfile architecture
  - [ ] Add configuration example in config.yaml

- [ ] Performance validation:
  - [ ] Verify 2.6x improvement for 1MB+ files
  - [ ] Verify no regression for small files
  - [ ] Memory usage verification (constant per connection)

### Files to Create/Modify
- `tests/sendfile_integration.rs` (new)
- `benches/sendfile_proxy.rs` (new)
- `README.md`
- `CLAUDE.md`
- `config.yaml.example`

---

## Implementation Notes

### sendfile Wrapper

```rust
#[cfg(target_os = "linux")]
pub fn sendfile_to_socket(
    socket_fd: RawFd,
    file_path: &Path,
    offset: u64,
    length: u64,
) -> io::Result<u64> {
    use std::fs::File;
    use std::os::unix::io::AsRawFd;

    let file = File::open(file_path)?;
    let file_fd = file.as_raw_fd();
    let mut off = offset as libc::off_t;
    let mut total_sent: u64 = 0;

    while total_sent < length {
        let to_send = std::cmp::min(length - total_sent, 0x7ffff000) as usize;
        let sent = unsafe {
            libc::sendfile(socket_fd, file_fd, &mut off, to_send)
        };

        if sent < 0 {
            let err = io::Error::last_os_error();
            if err.kind() == io::ErrorKind::WouldBlock {
                // Socket buffer full, would need to wait
                // In async context, yield and retry
                continue;
            }
            return Err(err);
        }
        if sent == 0 {
            break; // EOF
        }
        total_sent += sent as u64;
    }

    Ok(total_sent)
}
```

### Configuration

```yaml
cache:
  disk:
    enabled: true
    path: /var/cache/yatagarasu
    max_size_gb: 10
    # New sendfile options
    sendfile:
      enabled: true           # Enable sendfile on Linux
      threshold_bytes: 65536  # Use sendfile for files > 64KB
```

### Pingora Integration Challenge

Pingora manages socket connections internally. To use sendfile, we need to:

1. Get the downstream (client) socket's raw fd from Pingora's `Session`
2. This may require using Pingora's lower-level APIs or upstream contribution

**Fallback approach:** If direct fd access isn't available, implement sendfile at the response body level using Pingora's `upstream_response_body_filter` with direct fd writes when possible.

---

## Timeline

| Phase | Scope | Estimated Effort |
|-------|-------|------------------|
| Phase 1 | Abstraction Layer | Foundation |
| Phase 2 | DiskCache Integration | Core implementation |
| Phase 3 | Proxy Integration | Integration |
| Phase 4 | Testing & Docs | Validation |

---

## Success Criteria

- [ ] sendfile enabled by default on Linux
- [ ] 2.5x+ throughput improvement for 1MB+ cached files
- [ ] No regression for small files (<64KB)
- [ ] Graceful fallback on non-Linux platforms
- [ ] All existing tests pass
- [ ] New tests cover sendfile paths
- [ ] Documentation updated
